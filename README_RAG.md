# Унифицированный RAG-агент для Волонтерского Telegram бота

## Что такое RAG?

**RAG (Retrieval-Augmented Generation)** - это подход, который комбинирует поиск информации (Retrieval) и генеративные модели (Generation) для создания более точных и информативных ответов. Вместо того чтобы генерировать ответы "из головы", модель сначала ищет релевантную информацию в базе знаний, а затем использует найденную информацию для формирования ответа.

## Преимущества перед существующей архитектурой агентов

1. **Унификация кода** - один агент вместо множества специализированных
2. **Улучшенное понимание контекста** - агент работает с историей диалога и может понимать контекст запросов
3. **Гибкость** - легко добавлять новые типы запросов без создания новых агентов
4. **Лучшая работа с базой данных** - прямое извлечение информации из БД при необходимости
5. **Персонализированные ответы** - учет интересов пользователя при формировании ответов

## Как работает UnifiedRAGAgent

UnifiedRAGAgent объединяет функциональность всех предыдущих агентов:

1. **Определение намерения пользователя** - анализирует запрос и определяет тип запроса (информация о мероприятии, текущие мероприятия, рекомендации, общий диалог)
2. **Семантический поиск** - использует векторные вложения для поиска релевантной информации
3. **Прямой доступ к БД** - если семантический поиск не дал результатов, обращается напрямую к базе данных
4. **Генерация ответа** - формирует естественный ответ на основе найденной информации с учетом контекста диалога

## Интеграция в существующее приложение

Для использования UnifiedRAGAgent вместо текущих агентов:

### 1. Обновите обработчик ИИ-чата

```python
from services.ai import UnifiedRAGAgent

async def handle_ai_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.message.text.strip()
    if query.lower() in ["выход", "назад", "меню", "❌ отмена"]:
        context.user_data.pop("conversation_history", None)
        await update.message.reply_text(
            "Диалог прерван. Возвращаемся в главное меню.",
            reply_markup=get_main_menu_keyboard()
        )
        return MAIN_MENU

    if "conversation_history" not in context.user_data:
        context.user_data["conversation_history"] = []

    context.user_data["conversation_history"].append({"role": "user", "content": query})

    # Используем унифицированный RAG-агент
    rag_agent = UnifiedRAGAgent()
    response = rag_agent.process_query(
        query,
        user_id=update.effective_user.id,
        conversation_history=context.user_data["conversation_history"]
    )

    context.user_data["conversation_history"].append({"role": "assistant", "content": response})
    
    await update.message.reply_markdown(response)
    return AI_CHAT
```

### 2. Включите агент в services/ai/__init__.py

```python
from .unified_rag_agent import UnifiedRAGAgent

__all__ = [
    # ... другие агенты ...
    'UnifiedRAGAgent'
]
```

## Расширение функциональности

Чтобы добавить новый тип запросов, вам нужно:

1. Добавить новые шаблоны в метод `_detect_intent`
2. Создать новый обработчик в словаре `self.handlers`
3. Реализовать новый метод обработки, например:

```python
def _handle_new_query_type(self, query: str, **kwargs) -> str:
    # Логика обработки нового типа запросов
    # ...
    return self._generate_response(query, result_data, "new_query_type")
```

## Тестирование

Рекомендуется протестировать агент на различных типах запросов:

1. **Запросы о мероприятиях**: "Расскажи подробнее о ближайшем мероприятии по экологии"
2. **Запросы о текущих мероприятиях**: "Какие мероприятия сейчас проходят в Москве?"
3. **Запросы на рекомендации**: "Посоветуй мне мероприятие, я интересуюсь спортом"
4. **Общие вопросы**: "Привет, как дела?"
5. **Тестирование контекста**: "А есть ли там какие-то награды?" (после запроса о мероприятии)

## Миграция

Для миграции с текущей архитектуры на RAG-агент:

1. Оставьте существующие агенты до полного тестирования RAG-агента
2. При успешном тестировании, постепенно замените использование старых агентов на новый
3. После полного перехода на новый агент можно будет удалить неиспользуемый код агентов

## Конфигурация

При необходимости вы можете настроить следующие параметры агента:

- `temperature` в `GigaChatLLM` - влияет на креативность ответов
- Параметр `k` в методах поиска - количество результатов для извлечения
- Словарь шаблонов в `_detect_intent` - для точности определения типа запроса