from abc import ABC, abstractmethod
from database import Database
from source.gigachat import get_gigachat_response

tags = ['small_talk', 'events_recommendation'] #TODO: Перенести куда-то? Мб в бд хранить?

class AIAgent(ABC):
    """
    Abstract base class for AI agents that interact with the database and process user queries.
    """

    def __init__(self):
        """
        Initialize the AI agent with a connection to the database.
        """
        self.db = Database()

    @abstractmethod
    def process_query(self, query: str, user_id: int) -> str:
        """
        Process the given query for the specified user.

        :param query: The user's query as a string.
        :param user_id: The identifier of the user.
        :return: The response generated by the agent.
        """
        pass


class RecommendationAgent(AIAgent):
    """
    Agent that provides event recommendations based on the user's participation and available events.
    """

    def __init__(self):
        """
        Initialize the RecommendationAgent instance.
        """
        super().__init__()

    def get_user_events(self, user_id: int):
        """
        Retrieve the list of events in which the user has registered.

        :param user_id: The identifier of the user.
        :return: A list of event names that the user has participated in.
        """
        user = self.db.get_user(user_id)
        if user and user.get("registered_events"):
            return [e.strip() for e in user["registered_events"].split(",") if e.strip()]
        return []

    def get_all_events(self):
        """
        Retrieve all available events from the database.

        :return: A list of dictionaries, each representing an event with its details.
        """
        events = []
        with self.db.connect() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM events")
            for row in cursor.fetchall():
                events.append({
                    "id": row[0],
                    "name": row[1],
                    "date": row[2],
                    "time": row[3],
                    "count": row[4],
                    "points": row[5],
                    "curator": row[6],
                    "description": row[7]
                })
        return events

    def recommend_events(self, user_id: int) -> str:
        """
        Compose a prompt for GigaChat by including both the user's event history and the list of all available events,
        then request recommendations.

        The prompt includes:
          - The list of events the user has participated in.
          - The full list of available events with names, dates, and descriptions.
          - A request for recommendations based on the user's experience.

        :param user_id: The identifier of the user.
        :return: The recommended events as a formatted string.
        """
        all_events = self.get_all_events()
        user_events = self.get_user_events(user_id)
        all_events_text = "\n".join([
            f"- {event['name']} (Дата: {event['date']}, Описание: {event['description']})"
            for event in all_events
        ]) if all_events else "Нет доступных событий."
        user_events_text = "\n".join(user_events) if user_events else (
            "Пользователь ещё не участвовал в мероприятиях."
        )
        prompt = (
            "У пользователя есть следующий опыт участия в мероприятиях:\n"
            f"{user_events_text}\n\n"
            "Вот список всех доступных мероприятий:\n"
            f"{all_events_text}\n\n"
            "Пожалуйста, на основе этого опыта и списка мероприятий, дай рекомендации для пользователя, "
            "какие мероприятия ему стоит посетить. Укажи названия рекомендованных мероприятий и кратко обоснуй свой выбор. "
            "Ты заинтересован в этом, с увлечением отвечаешь пользователю, делаешь это крайне уважительно. "
            "Если пользователь не принимал участия в мероприятиях, предложи из доступных. "
            "Если нет доступных, скажи, что на данный момент мероприятия не проходят. "
            "Не используй markdown, сделай текст красивым для telegram. Используй emoji. "
        )
        response = get_gigachat_response({"messages": [{"role": "user", "content": prompt}]})
        return response.strip()

    def process_query(self, query: str, user_id: int) -> str:
        """
        Process the user's query by first generating local recommendations and then asking GigaChat
        to evaluate and provide additional insights.

        :param query: The user's query (not used directly in this implementation).
        :param user_id: The identifier of the user.
        :return: The final response from the agent.
        """
        rec_text = self.recommend_events(user_id)
        prompt = (
            f"Оцени следующие рекомендации для пользователя с учетом его предпочтений:\n"
            f"{rec_text}\n"
            "Дай финальную оценку и дополнительные рекомендации, если необходимо."
        )
        response = get_gigachat_response({"messages": [{"role": "user", "content": prompt}]})
        return response.strip()

class ContextRouterAgent(AIAgent):
    def __init__(self):
        super().__init__()
        self.recommendation_agent = RecommendationAgent()
        self.allowed_topics = ["Все"]

    def process_query(self, query: str, user_id: int) -> str:
        lower_query = query.lower()
        prompt = (f"Ты - оркестровый агент, выбираешь кому делегировать задачу. \n"
                  f"Пользователь ввёл запрос: {lower_query}\n"
                  f"Разбери запрос и пойми о чём хочет говорить пользователь, для этого у тебя на выбор есть следующие теги: {tags} \n"
                  f"В ответ я должен получить только 1 тег из предложенных, ничего кроме этого. \n")
        response = get_gigachat_response({"messages": [{"role": "user", "content": prompt}]})

        if "events_recommendation" in response:
            return self.recommendation_agent.recommend_events(user_id)
        # Если сообщение затрагивает разрешённые темы
        elif "small_talk" in response:
            return self.default_response(query)
        else:
            topics = ", ".join(self.allowed_topics)
            return ("Извините, я не смог понять ваш запрос. "
                    "Пожалуйста, уточните его или поговорите на одну из следующих тем: " + topics)

    def default_response(self, query: str) -> str:
        # Здесь можно сформировать промпт для GigaChat для генерации ответа
        prompt = (f"Пользователь задал вопрос: {query}\n"
                  "Ответь дружелюбно и информативно, используя стиль, подходящий для общения в Telegram.")
        response = get_gigachat_response({"messages": [{"role": "user", "content": prompt}]})
        return response.strip()
